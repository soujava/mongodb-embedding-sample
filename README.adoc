= Jakarta NoSQL with MongoDB: Exploring Embedded Documents and Flexibility

This project demonstrates the use of Jakarta NoSQL with MongoDB, leveraging the flexibility of Helidon MP to build a sample RESTful API for managing products. The focus is on showcasing how MongoDB's embedded document model works in conjunction with Jakarta NoSQL, emphasizing:

- The simplicity of modeling entities with embedded types.
- Flexibility in handling relationships such as `One-to-One`, `One-to-Many`, and `Many-to-Many`.
- Dynamic schemas and their adaptability to real-world use cases.

The project serves as a practical guide for developers to understand how to use Jakarta NoSQL annotations to map MongoDB documents, demonstrating MongoDB's unique capabilities for handling flexible and embedded data structures.

== Build and Run

With JDK21:
[source,bash]
----
mvn package
java -jar target/embedded-mongodb.jar
----

== Exercise the Application

Basic:
[source,bash]
----
curl -X GET http://localhost:8080/products
----

JSON:
[source,bash]
----
# Create a product
curl -X POST -H "Content-Type: application/json" -d '{
    "name": "Smartphone",
    "manufacturer": {
        "name": "Tech Co",
        "address": "1234 Tech Street",
        "contactNumber": "+123456789"
    },
    "tags": ["mobile", "smart"],
    "categories": [
        {"name": "Electronics", "description": "Devices and gadgets."},
        {"name": "Gadgets", "description": "Small useful tools and devices."}
    ]
}' http://localhost:8080/products

# Get all products (paginated)
curl -X GET http://localhost:8080/products?page=1&size=10

# Get a specific product by ID
curl -X GET http://localhost:8080/products/{id}

# Delete a product by ID
curl -X DELETE http://localhost:8080/products/{id}
----

== Project Goals

This project highlights:
- **Jakarta NoSQL Integration with MongoDB**: Demonstrating how Jakarta NoSQL simplifies database interactions using annotations and abstractions.
- **MongoDB Embedded Documents**: Showcasing the use of embedded types (`Manufacturer` and `Category`) to take advantage of MongoDB’s schema-less design.
- **Flexibility of MongoDB**: Illustrating how MongoDB handles arrays, embedded objects, and relationships without requiring a rigid schema.
- **Helidon MP as a Lightweight Framework**: Using Helidon MP for building modern REST APIs with minimal configuration and overhead.

== Try Health

[source,bash]
----
curl -s -X GET http://localhost:8080/health
{"outcome":"UP",...
----

== Building a Native Image

The generation of native binaries requires an installation of GraalVM 22.1.0+.

You can build a native binary using Maven as follows:
[source,bash]
----
mvn -Pnative-image install -DskipTests
----

The generation of the executable binary may take a few minutes to complete depending on your hardware and operating system. When completed, the executable file will be available under the `target` directory and named after the artifact ID you have chosen during the project generation phase.

== Try Metrics

[source,bash]
----
# Prometheus Format
curl -s -X GET http://localhost:8080/metrics
# TYPE base:gc_g1_young_generation_count gauge
. . .

# JSON Format
curl -H 'Accept: application/json' -X GET http://localhost:8080/metrics
{"base":...
. . .
----

== Building the Docker Image

[source,bash]
----
docker build -t embedded-mongodb .
----

== Running the Docker Image

[source,bash]
----
docker run --rm -p 8080:8080 embedded-mongodb:latest
----

Exercise the application as described above.

== Run the Application in Kubernetes

If you don’t have access to a Kubernetes cluster, you can https://helidon.io/docs/latest/#/about/kubernetes[install one] on your desktop.

=== Verify Connectivity to Cluster

[source,bash]
----
kubectl cluster-info                        # Verify which cluster
kubectl get pods                            # Verify connectivity to cluster
----

=== Deploy the Application to Kubernetes

[source,bash]
----
kubectl create -f app.yaml                              # Deploy application
kubectl get pods                                        # Wait for quickstart pod to be RUNNING
kubectl get service  embedded-mongodb                  # Get service info
kubectl port-forward service/embedded-mongodb 8081:8080   # Forward service port to 8081
----

You can now exercise the application as you did before but use the port number 8081.

After you’re done, cleanup:
[source,bash]
----
kubectl delete -f app.yaml
----

== Building a Custom Runtime Image

Build the custom runtime image using the jlink image profile:
[source,bash]
----
mvn package -Pjlink-image
----

This uses the helidon-maven-plugin to perform the custom image generation. After the build completes, it will report some statistics about the build, including the reduction in image size.

The `target/embedded-mongodb-jri` directory is a self-contained custom image of your application. It contains your application, its runtime dependencies, and the JDK modules it depends on. You can start your application using the provided start script:
[source,bash]
----
./target/embedded-mongodb-jri/bin/start
----

=== Class Data Sharing (CDS) Archive

Also included in the custom image is a Class Data Sharing (CDS) archive that improves your application’s startup performance and in-memory footprint. You can learn more about Class Data Sharing in the JDK documentation.

The CDS archive increases your image size to get these performance optimizations. It can be of significant size (tens of MB). The size of the CDS archive is reported at the end of the build output.

If you’d rather have a smaller image size (with a slightly increased startup time), you can skip the creation of the CDS archive by executing your build like this:
[source,bash]
----
mvn package -Pjlink-image -Djlink.image.addClassDataSharingArchive=false
----

For more information on available configuration options, see the helidon-maven-plugin documentation.
